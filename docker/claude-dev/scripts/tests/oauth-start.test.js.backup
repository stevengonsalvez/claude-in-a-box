// ABOUTME: Comprehensive behavioral tests for OAuth start script
// Tests OAuth login URL generation, PKCE implementation, and state management

const { test, describe, it, mock, beforeEach, afterEach } = require('node:test');
const assert = require('node:assert');
const crypto = require('crypto');
const fs = require('fs').promises;
const path = require('path');
const { tmpdir } = require('os');

const {
  OAUTH_CONSTANTS,
  generateState,
  generatePKCE,
  saveState,
  generateLoginUrl,
  startOAuthLogin
} = require('../oauth-start.js');

// Test data factory for OAuth state
const getMockOAuthState = (overrides = {}) => ({
  state: 'a'.repeat(64), // 64 char hex string
  codeVerifier: 'test-code-verifier-base64url-encoded-string',
  timestamp: Date.now(),
  ...overrides
});

// Utility functions for test validation
const isValidHexString = (str, expectedLength) => {
  return typeof str === 'string' &&
         str.length === expectedLength &&
         /^[a-f0-9]+$/i.test(str);
};

const isValidBase64Url = (str) => {
  return typeof str === 'string' &&
         /^[A-Za-z0-9_-]+$/.test(str);
};

const base64UrlEncode = (buffer) => {
  return buffer.toString('base64')
    .replace(/\+/g, '-')
    .replace(/\//g, '_')
    .replace(/=/g, '');
};

describe('OAuth Start Script', () => {
  let originalProcessEnv;
  let tempDir;
  let testStateFile;

  beforeEach(async () => {
    // Backup original environment
    originalProcessEnv = { ...process.env };

    // Create temporary directory for test state files
    tempDir = await fs.mkdtemp(path.join(tmpdir(), 'oauth-test-'));
    testStateFile = path.join(tempDir, '.claude_oauth_state.json');

    // Set test environment
    process.env.HOME = tempDir;
  });

  afterEach(async () => {
    // Restore original environment
    process.env = originalProcessEnv;

    // Clean up test files
    try {
      await fs.rm(tempDir, { recursive: true, force: true });
    } catch (error) {
      // Ignore cleanup errors
    }
  });

  describe('OAuth Constants', () => {
    it('should have correct OAuth configuration values', () => {
      assert.strictEqual(OAUTH_CONSTANTS.CLIENT_ID, '9d1c250a-e61b-44d9-88ed-5944d1962f5e');
      assert.strictEqual(OAUTH_CONSTANTS.OAUTH_AUTHORIZE_URL, 'https://claude.ai/oauth/authorize');
      assert.strictEqual(OAUTH_CONSTANTS.REDIRECT_URI, 'https://console.anthropic.com/oauth/code/callback');
      assert.strictEqual(OAUTH_CONSTANTS.SCOPES, 'org:create_api_key user:profile user:inference');
    });

    it('should have reasonable state expiry time', () => {
      assert.strictEqual(typeof OAUTH_CONSTANTS.STATE_EXPIRY_MINUTES, 'number');
      assert(OAUTH_CONSTANTS.STATE_EXPIRY_MINUTES > 0);
      assert(OAUTH_CONSTANTS.STATE_EXPIRY_MINUTES <= 60); // Max 1 hour for security
    });

    it('should construct state file path using HOME environment variable', () => {
      assert(OAUTH_CONSTANTS.STATE_FILE.includes('.claude'));
      assert(OAUTH_CONSTANTS.STATE_FILE.endsWith('.claude_oauth_state.json'));
    });
  });

  describe('generateState()', () => {
    it('should generate a 64-character hexadecimal string', () => {
      const state = generateState();

      assert.strictEqual(typeof state, 'string');
      assert.strictEqual(state.length, 64);
      assert(isValidHexString(state, 64), 'State should be valid hex string');
    });

    it('should generate different values on each call', () => {
      const state1 = generateState();
      const state2 = generateState();

      assert.notStrictEqual(state1, state2, 'Each state should be unique');
    });

    it('should generate cryptographically random values', () => {
      const states = new Set();
      const iterations = 100;

      for (let i = 0; i < iterations; i++) {
        states.add(generateState());
      }

      // All states should be unique (probability of collision is negligible)
      assert.strictEqual(states.size, iterations, 'All generated states should be unique');
    });

    it('should use exactly 32 bytes of randomness', () => {
      const state = generateState();

      // 32 bytes = 64 hex characters
      assert.strictEqual(state.length, 64);

      // Verify it represents exactly 32 bytes
      const buffer = Buffer.from(state, 'hex');
      assert.strictEqual(buffer.length, 32);
    });
  });

  describe('generatePKCE()', () => {
    it('should return object with codeVerifier and codeChallenge', () => {
      const pkce = generatePKCE();

      assert.strictEqual(typeof pkce, 'object');
      assert('codeVerifier' in pkce);
      assert('codeChallenge' in pkce);
      assert.strictEqual(typeof pkce.codeVerifier, 'string');
      assert.strictEqual(typeof pkce.codeChallenge, 'string');
    });

    it('should generate codeVerifier as base64url-encoded 32-byte string', () => {
      const { codeVerifier } = generatePKCE();

      assert(isValidBase64Url(codeVerifier), 'Code verifier should be base64url encoded');

      // Decode and verify it's 32 bytes
      const decoded = Buffer.from(codeVerifier + '==', 'base64'); // Add padding for decoding
      assert(decoded.length >= 32, 'Code verifier should represent at least 32 bytes');
    });

    it('should generate codeChallenge as SHA256 hash of codeVerifier in base64url', () => {
      const { codeVerifier, codeChallenge } = generatePKCE();

      // Manually calculate expected challenge
      const hash = crypto.createHash('sha256').update(codeVerifier).digest();
      const expectedChallenge = base64UrlEncode(hash);

      assert.strictEqual(codeChallenge, expectedChallenge);
      assert(isValidBase64Url(codeChallenge), 'Code challenge should be base64url encoded');
    });

    it('should generate different PKCE pairs on each call', () => {
      const pkce1 = generatePKCE();
      const pkce2 = generatePKCE();

      assert.notStrictEqual(pkce1.codeVerifier, pkce2.codeVerifier);
      assert.notStrictEqual(pkce1.codeChallenge, pkce2.codeChallenge);
    });

    it('should generate codeChallenge that is exactly 43 characters (SHA256 base64url)', () => {
      const { codeChallenge } = generatePKCE();

      // SHA256 produces 32 bytes, base64url encoding without padding = 43 chars
      assert.strictEqual(codeChallenge.length, 43);
    });
  });

  describe('saveState()', () => {
    const testState = 'a'.repeat(64);
    const testCodeVerifier = 'test-code-verifier';

    it('should save state and codeVerifier to JSON file', async () => {
      await saveState(testState, testCodeVerifier);

      const savedData = JSON.parse(await fs.readFile(testStateFile, 'utf8'));

      assert.strictEqual(savedData.state, testState);
      assert.strictEqual(savedData.codeVerifier, testCodeVerifier);
    });

    it('should include timestamp in saved state', async () => {
      const beforeTime = Date.now();
      await saveState(testState, testCodeVerifier);
      const afterTime = Date.now();

      const savedData = JSON.parse(await fs.readFile(testStateFile, 'utf8'));

      assert(savedData.timestamp >= beforeTime);
      assert(savedData.timestamp <= afterTime);
    });

    it('should create .claude directory if it does not exist', async () => {
      // Remove the directory to test creation
      await fs.rm(path.dirname(testStateFile), { recursive: true, force: true });

      await saveState(testState, testCodeVerifier);

      // Verify file was created (directory must have been created too)
      const savedData = JSON.parse(await fs.readFile(testStateFile, 'utf8'));
      assert.strictEqual(savedData.state, testState);
    });

    it('should overwrite existing state file', async () => {
      const firstState = 'first' + 'a'.repeat(59);
      const secondState = 'second' + 'a'.repeat(58);

      await saveState(firstState, 'first-verifier');
      await saveState(secondState, 'second-verifier');

      const savedData = JSON.parse(await fs.readFile(testStateFile, 'utf8'));
      assert.strictEqual(savedData.state, secondState);
      assert.strictEqual(savedData.codeVerifier, 'second-verifier');
    });

    it('should validate state parameter format', async () => {
      await assert.rejects(
        () => saveState('invalid-short-state', testCodeVerifier),
        { message: /Invalid state format/ }
      );

      await assert.rejects(
        () => saveState('not-hex-characters-!!!', testCodeVerifier),
        { message: /Invalid state format/ }
      );
    });

    it('should validate codeVerifier parameter', async () => {
      await assert.rejects(
        () => saveState(testState, ''),
        { message: /Invalid code verifier/ }
      );

      await assert.rejects(
        () => saveState(testState, null),
        { message: /Invalid code verifier/ }
      );
    });
  });

  describe('generateLoginUrl()', () => {
    it('should generate URL with correct base and client_id', async () => {
      const url = await generateLoginUrl();
      const parsedUrl = new URL(url);

      assert.strictEqual(parsedUrl.origin + parsedUrl.pathname, OAUTH_CONSTANTS.OAUTH_AUTHORIZE_URL);
      assert.strictEqual(parsedUrl.searchParams.get('client_id'), OAUTH_CONSTANTS.CLIENT_ID);
    });

    it('should include all required OAuth parameters', async () => {
      const url = await generateLoginUrl();
      const parsedUrl = new URL(url);

      assert.strictEqual(parsedUrl.searchParams.get('response_type'), 'code');
      assert.strictEqual(parsedUrl.searchParams.get('redirect_uri'), OAUTH_CONSTANTS.REDIRECT_URI);
      assert.strictEqual(parsedUrl.searchParams.get('scope'), OAUTH_CONSTANTS.SCOPES);
    });

    it('should include valid PKCE parameters', async () => {
      const url = await generateLoginUrl();
      const parsedUrl = new URL(url);

      const codeChallenge = parsedUrl.searchParams.get('code_challenge');
      const codeChallengeMethod = parsedUrl.searchParams.get('code_challenge_method');

      assert(codeChallenge, 'URL should include code_challenge');
      assert.strictEqual(codeChallengeMethod, 'S256');
      assert.strictEqual(codeChallenge.length, 43); // SHA256 base64url length
      assert(isValidBase64Url(codeChallenge), 'Code challenge should be base64url encoded');
    });

    it('should include valid state parameter', async () => {
      const url = await generateLoginUrl();
      const parsedUrl = new URL(url);

      const state = parsedUrl.searchParams.get('state');

      assert(state, 'URL should include state parameter');
      assert.strictEqual(state.length, 64);
      assert(isValidHexString(state, 64), 'State should be 64-char hex string');
    });

    it('should save state and code verifier when generating URL', async () => {
      const url = await generateLoginUrl();
      const parsedUrl = new URL(url);

      // Verify state file was created with matching state
      const savedData = JSON.parse(await fs.readFile(testStateFile, 'utf8'));
      assert.strictEqual(savedData.state, parsedUrl.searchParams.get('state'));
      assert(savedData.codeVerifier, 'Code verifier should be saved');
      assert(savedData.timestamp, 'Timestamp should be included');
    });

    it('should generate different URLs on each call', async () => {
      const url1 = await generateLoginUrl();
      const url2 = await generateLoginUrl();

      const parsed1 = new URL(url1);
      const parsed2 = new URL(url2);

      // States should be different
      assert.notStrictEqual(
        parsed1.searchParams.get('state'),
        parsed2.searchParams.get('state')
      );

      // Code challenges should be different
      assert.notStrictEqual(
        parsed1.searchParams.get('code_challenge'),
        parsed2.searchParams.get('code_challenge')
      );
    });

    it('should encode URL parameters correctly', async () => {
      const url = await generateLoginUrl();
      const parsedUrl = new URL(url);

      // Verify scope parameter is properly encoded (contains spaces)
      const scope = parsedUrl.searchParams.get('scope');
      assert.strictEqual(scope, OAUTH_CONSTANTS.SCOPES);

      // Verify redirect URI is properly encoded
      const redirectUri = parsedUrl.searchParams.get('redirect_uri');
      assert.strictEqual(redirectUri, OAUTH_CONSTANTS.REDIRECT_URI);
    });
  });

  describe('startOAuthLogin()', () => {
    let consoleSpy;

    beforeEach(() => {
      consoleSpy = mock.method(console, 'log', () => {});
    });

    afterEach(() => {
      consoleSpy?.mock?.restore();
    });

    it('should generate and output OAuth login URL', async () => {
      await startOAuthLogin();

      // Verify console.log was called
      assert(consoleSpy.mock.calls.length > 0, 'Should output URL to console');

      // Verify the output contains a valid URL
      const output = consoleSpy.mock.calls.find(call =>
        call.arguments[0] && call.arguments[0].includes('https://claude.ai/oauth/authorize')
      );
      assert(output, 'Should output OAuth authorization URL');

      // Verify it's a valid URL
      const urlOutput = output.arguments[0];
      assert.doesNotThrow(() => new URL(urlOutput), 'Output should be valid URL');
    });

    it('should save state file during execution', async () => {
      await startOAuthLogin();

      // Verify state file was created
      const savedData = JSON.parse(await fs.readFile(testStateFile, 'utf8'));
      assert(savedData.state, 'State should be saved');
      assert(savedData.codeVerifier, 'Code verifier should be saved');
      assert(savedData.timestamp, 'Timestamp should be saved');
    });

    it('should handle file system errors gracefully', async () => {
      // Make directory read-only to simulate permission error
      await fs.chmod(tempDir, 0o444);

      await assert.rejects(
        () => startOAuthLogin(),
        { name: 'Error' }
      );

      // Restore permissions for cleanup
      await fs.chmod(tempDir, 0o755);
    });

    it('should provide helpful error message on failure', async () => {
      // Temporarily break the HOME environment to cause an error
      delete process.env.HOME;

      await assert.rejects(
        () => startOAuthLogin(),
        { message: /OAuth start failed|path|HOME/ }
      );
    });
  });

  describe('CLI Integration', () => {
    it('should export all required functions for CLI usage', () => {
      const expectedExports = [
        'OAUTH_CONSTANTS',
        'generateState',
        'generatePKCE',
        'saveState',
        'generateLoginUrl',
        'startOAuthLogin'
      ];

      expectedExports.forEach(exportName => {
        assert(exportName in require('../oauth-start.js'),
          `Should export ${exportName} function`);
      });
    });

    it('should validate exported function types', () => {
      const exports = require('../oauth-start.js');

      assert.strictEqual(typeof exports.OAUTH_CONSTANTS, 'object');
      assert.strictEqual(typeof exports.generateState, 'function');
      assert.strictEqual(typeof exports.generatePKCE, 'function');
      assert.strictEqual(typeof exports.saveState, 'function');
      assert.strictEqual(typeof exports.generateLoginUrl, 'function');
      assert.strictEqual(typeof exports.startOAuthLogin, 'function');
    });
  });

  describe('Security Considerations', () => {
    it('should use cryptographically secure random generation', () => {
      // Test by checking entropy - multiple calls should produce different results
      const values = new Set();
      for (let i = 0; i < 50; i++) {
        values.add(generateState());
      }

      // With crypto.randomBytes, all 50 should be unique
      assert.strictEqual(values.size, 50, 'Should generate unique random values');
    });

    it('should follow PKCE RFC 7636 specifications', () => {
      const { codeVerifier, codeChallenge } = generatePKCE();

      // RFC 7636 requirements
      assert(codeVerifier.length >= 43, 'Code verifier should be at least 43 characters');
      assert(codeVerifier.length <= 128, 'Code verifier should be at most 128 characters');
      assert(isValidBase64Url(codeVerifier), 'Code verifier should be base64url encoded');

      // Challenge should be SHA256 of verifier
      const expectedChallenge = base64UrlEncode(
        crypto.createHash('sha256').update(codeVerifier).digest()
      );
      assert.strictEqual(codeChallenge, expectedChallenge);
    });

    it('should include timestamp for state expiration tracking', async () => {
      await saveState('a'.repeat(64), 'test-verifier');

      const savedData = JSON.parse(await fs.readFile(testStateFile, 'utf8'));
      assert(typeof savedData.timestamp === 'number');
      assert(savedData.timestamp > 0);
      assert(savedData.timestamp <= Date.now());
    });
  });

  describe('Error Handling Edge Cases', () => {
    it('should handle missing HOME environment variable', async () => {
      delete process.env.HOME;

      await assert.rejects(
        () => generateLoginUrl(),
        { message: /HOME/ }
      );
    });

    it('should handle invalid file permissions', async () => {
      // Create a file where directory should be
      const dirPath = path.dirname(testStateFile);
      await fs.mkdir(dirPath, { recursive: true });
      await fs.chmod(dirPath, 0o000); // No permissions

      await assert.rejects(
        () => saveState('a'.repeat(64), 'test-verifier'),
        { code: 'EACCES' }
      );

      // Restore permissions for cleanup
      await fs.chmod(dirPath, 0o755);
    });

    it('should validate input parameters thoroughly', async () => {
      // Test various invalid inputs
      await assert.rejects(() => saveState(null, 'valid'), { message: /Invalid state/ });
      await assert.rejects(() => saveState(undefined, 'valid'), { message: /Invalid state/ });
      await assert.rejects(() => saveState('', 'valid'), { message: /Invalid state/ });
      await assert.rejects(() => saveState('short', 'valid'), { message: /Invalid state/ });
      await assert.rejects(() => saveState('a'.repeat(64), null), { message: /Invalid code verifier/ });
      await assert.rejects(() => saveState('a'.repeat(64), ''), { message: /Invalid code verifier/ });
    });
  });
});

// Test data validation utilities
describe('Test Utilities', () => {
  describe('isValidHexString()', () => {
    it('should correctly identify valid hex strings', () => {
      assert(isValidHexString('abc123', 6));
      assert(isValidHexString('ABC123', 6));
      assert(isValidHexString('abcdef0123456789', 16));
    });

    it('should reject invalid hex strings', () => {
      assert(!isValidHexString('xyz123', 6)); // Invalid characters
      assert(!isValidHexString('abc12', 6));   // Wrong length
      assert(!isValidHexString('abc123g', 7)); // Invalid character
      assert(!isValidHexString('', 0));        // Empty string
    });
  });

  describe('isValidBase64Url()', () => {
    it('should correctly identify valid base64url strings', () => {
      assert(isValidBase64Url('abc123'));
      assert(isValidBase64Url('ABC123'));
      assert(isValidBase64Url('abc-123_def'));
      assert(isValidBase64Url('a1b2c3d4e5f6'));
    });

    it('should reject invalid base64url strings', () => {
      assert(!isValidBase64Url('abc+123'));  // Contains +
      assert(!isValidBase64Url('abc/123'));  // Contains /
      assert(!isValidBase64Url('abc=123'));  // Contains =
      assert(!isValidBase64Url('abc 123'));  // Contains space
    });
  });

  describe('getMockOAuthState()', () => {
    it('should generate mock OAuth state with defaults', () => {
      const mock = getMockOAuthState();

      assert.strictEqual(mock.state, 'a'.repeat(64));
      assert.strictEqual(mock.codeVerifier, 'test-code-verifier-base64url-encoded-string');
      assert(typeof mock.timestamp === 'number');
    });

    it('should allow overriding default values', () => {
      const mock = getMockOAuthState({
        state: 'custom-state',
        timestamp: 12345
      });

      assert.strictEqual(mock.state, 'custom-state');
      assert.strictEqual(mock.timestamp, 12345);
      assert.strictEqual(mock.codeVerifier, 'test-code-verifier-base64url-encoded-string'); // Default preserved
    });
  });
});
