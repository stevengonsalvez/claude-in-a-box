// ABOUTME: Comprehensive test suite for OAuth finish script that handles authorization code exchange,
// token storage, and state cleanup with extensive error handling scenarios.

const fs = require('fs').promises;
const path = require('path');
const os = require('os');

// Mock modules before importing the module under test
jest.mock('fs', () => ({
  promises: {
    readFile: jest.fn(),
    writeFile: jest.fn(),
    unlink: jest.fn(),
    access: jest.fn(),
    mkdir: jest.fn(),
  },
}));

jest.mock('https', () => ({
  request: jest.fn(),
}));

const https = require('https');

describe('OAuth Finish Script', () => {
  let mockProcess;
  let mockConsole;

  beforeEach(() => {
    // Reset all mocks
    jest.clearAllMocks();

    // Mock process.argv and exit
    mockProcess = {
      argv: ['node', 'oauth-finish.js', 'test-auth-code'],
      exit: jest.fn(),
    };

    // Mock console methods
    mockConsole = {
      log: jest.fn(),
      error: jest.fn(),
    };

    // Mock global objects
    global.process = mockProcess;
    global.console = mockConsole;
  });

  describe('State Loading', () => {
    const mockStatePath = '/tmp/oauth-state.json';
    const validState = {
      state: 'test-state-123',
      code_verifier: 'test-code-verifier-456',
      timestamp: Date.now(),
    };

    beforeEach(() => {
      process.env.TMPDIR = '/tmp';
    });

    it('should successfully load valid state file', async () => {
      // Arrange
      fs.readFile.mockResolvedValue(JSON.stringify(validState));

      // Act - This would be called by the actual implementation
      const stateContent = await fs.readFile(mockStatePath, 'utf8');
      const parsedState = JSON.parse(stateContent);

      // Assert
      expect(fs.readFile).toHaveBeenCalledWith(mockStatePath, 'utf8');
      expect(parsedState.state).toBe(validState.state);
      expect(parsedState.code_verifier).toBe(validState.code_verifier);
      expect(parsedState.timestamp).toBe(validState.timestamp);
    });

    it('should handle missing state file', async () => {
      // Arrange
      const error = new Error('ENOENT: no such file or directory');
      error.code = 'ENOENT';
      fs.readFile.mockRejectedValue(error);

      // Act & Assert
      await expect(fs.readFile(mockStatePath, 'utf8')).rejects.toThrow('ENOENT: no such file or directory');
    });

    it('should handle malformed JSON in state file', async () => {
      // Arrange
      fs.readFile.mockResolvedValue('invalid json content {');

      // Act & Assert
      const stateContent = await fs.readFile(mockStatePath, 'utf8');
      expect(() => JSON.parse(stateContent)).toThrow();
    });

    it('should handle state file with missing required fields', async () => {
      // Arrange
      const incompleteState = { state: 'test-state' }; // Missing code_verifier
      fs.readFile.mockResolvedValue(JSON.stringify(incompleteState));

      // Act
      const stateContent = await fs.readFile(mockStatePath, 'utf8');
      const parsedState = JSON.parse(stateContent);

      // Assert
      expect(parsedState.code_verifier).toBeUndefined();
      expect(parsedState.state).toBe('test-state');
    });

    it('should handle expired state based on timestamp', async () => {
      // Arrange
      const expiredState = {
        ...validState,
        timestamp: Date.now() - (11 * 60 * 1000), // 11 minutes ago (expired)
      };
      fs.readFile.mockResolvedValue(JSON.stringify(expiredState));

      // Act
      const stateContent = await fs.readFile(mockStatePath, 'utf8');
      const parsedState = JSON.parse(stateContent);

      // Assert
      expect(parsedState.timestamp).toBeLessThan(Date.now() - (10 * 60 * 1000));
    });
  });

  describe('Command Line Arguments', () => {
    it('should accept authorization code from command line', () => {
      // Arrange
      const expectedCode = 'auth-code-12345';
      mockProcess.argv = ['node', 'oauth-finish.js', expectedCode];

      // Act
      const authCode = mockProcess.argv[2];

      // Assert
      expect(authCode).toBe(expectedCode);
    });

    it('should handle missing authorization code', () => {
      // Arrange
      mockProcess.argv = ['node', 'oauth-finish.js'];

      // Act
      const authCode = mockProcess.argv[2];

      // Assert
      expect(authCode).toBeUndefined();
    });

    it('should handle empty authorization code', () => {
      // Arrange
      mockProcess.argv = ['node', 'oauth-finish.js', ''];

      // Act
      const authCode = mockProcess.argv[2];

      // Assert
      expect(authCode).toBe('');
    });
  });

  describe('OAuth Token Exchange', () => {
    const mockAuthCode = 'test-auth-code';
    const mockState = 'test-state-123';
    const mockCodeVerifier = 'test-code-verifier-456';

    it('should make correct POST request to token endpoint', async () => {
      // Arrange
      const mockRequest = {
        write: jest.fn(),
        end: jest.fn(),
        on: jest.fn(),
      };

      const mockResponse = {
        statusCode: 200,
        on: jest.fn(),
      };

      https.request.mockImplementation((options, callback) => {
        // Verify request options
        expect(options.hostname).toBe('console.anthropic.com');
        expect(options.port).toBe(443);
        expect(options.path).toBe('/v1/oauth/token');
        expect(options.method).toBe('POST');
        expect(options.headers['Content-Type']).toBe('application/x-www-form-urlencoded');

        // Simulate successful response
        callback(mockResponse);

        return mockRequest;
      });

      // Expected request body
      const expectedBody = new URLSearchParams({
        grant_type: 'authorization_code',
        client_id: '9d1c250a-e61b-44d9-88ed-5944d1962f5e',
        code: mockAuthCode,
        redirect_uri: 'https://console.anthropic.com/oauth/code/callback',
        code_verifier: mockCodeVerifier,
        state: mockState,
      }).toString();

      // Act - This would be the actual implementation
      const req = https.request({
        hostname: 'console.anthropic.com',
        port: 443,
        path: '/v1/oauth/token',
        method: 'POST',
        headers: {
          'Content-Type': 'application/x-www-form-urlencoded',
          'Content-Length': Buffer.byteLength(expectedBody),
        },
      }, (res) => {});

      req.write(expectedBody);
      req.end();

      // Assert
      expect(https.request).toHaveBeenCalledTimes(1);
      expect(mockRequest.write).toHaveBeenCalledWith(expectedBody);
      expect(mockRequest.end).toHaveBeenCalledTimes(1);
    });

    it('should handle successful token response', async () => {
      // Arrange
      const mockTokenResponse = {
        access_token: 'access_token_12345',
        refresh_token: 'refresh_token_67890',
        expires_in: 3600,
        token_type: 'Bearer',
        scope: 'user:inference user:profile',
      };

      const mockRequest = {
        write: jest.fn(),
        end: jest.fn(),
        on: jest.fn(),
      };

      const mockResponse = {
        statusCode: 200,
        on: jest.fn(),
      };

      https.request.mockImplementation((options, callback) => {
        callback(mockResponse);
        return mockRequest;
      });

      // Simulate data chunks and end event
      mockResponse.on.mockImplementation((event, handler) => {
        if (event === 'data') {
          handler(JSON.stringify(mockTokenResponse));
        } else if (event === 'end') {
          handler();
        }
      });

      // Act
      let responseData = '';
      mockResponse.on('data', (chunk) => {
        responseData += chunk;
      });

      mockResponse.on('end', () => {
        const parsedResponse = JSON.parse(responseData);
        expect(parsedResponse.access_token).toBe(mockTokenResponse.access_token);
        expect(parsedResponse.refresh_token).toBe(mockTokenResponse.refresh_token);
        expect(parsedResponse.expires_in).toBe(mockTokenResponse.expires_in);
      });
    });

    it('should handle HTTP error responses', async () => {
      // Arrange
      const mockRequest = {
        write: jest.fn(),
        end: jest.fn(),
        on: jest.fn(),
      };

      const mockResponse = {
        statusCode: 400,
        on: jest.fn(),
      };

      const errorResponse = {
        error: 'invalid_grant',
        error_description: 'The provided authorization grant is invalid',
      };

      https.request.mockImplementation((options, callback) => {
        callback(mockResponse);
        return mockRequest;
      });

      mockResponse.on.mockImplementation((event, handler) => {
        if (event === 'data') {
          handler(JSON.stringify(errorResponse));
        } else if (event === 'end') {
          handler();
        }
      });

      // Act & Assert
      let responseData = '';
      mockResponse.on('data', (chunk) => {
        responseData += chunk;
      });

      mockResponse.on('end', () => {
        expect(mockResponse.statusCode).toBe(400);
        const parsedError = JSON.parse(responseData);
        expect(parsedError.error).toBe('invalid_grant');
      });
    });

    it('should handle network errors', async () => {
      // Arrange
      const mockRequest = {
        write: jest.fn(),
        end: jest.fn(),
        on: jest.fn(),
      };

      https.request.mockImplementation(() => {
        return mockRequest;
      });

      const networkError = new Error('ECONNREFUSED');
      networkError.code = 'ECONNREFUSED';

      mockRequest.on.mockImplementation((event, handler) => {
        if (event === 'error') {
          handler(networkError);
        }
      });

      // Act
      let caughtError;
      mockRequest.on('error', (error) => {
        caughtError = error;
      });

      // Trigger the error
      mockRequest.on.mock.calls.find(call => call[0] === 'error')[1](networkError);

      // Assert
      expect(caughtError).toBe(networkError);
      expect(caughtError.code).toBe('ECONNREFUSED');
    });
  });

  describe('Credentials Storage', () => {
    const mockTokenData = {
      access_token: 'access_token_12345',
      refresh_token: 'refresh_token_67890',
      expires_in: 3600,
    };

    const expectedCredentialsPath = path.join(os.homedir(), '.claude', '.credentials.json');

    it('should save credentials in correct format', async () => {
      // Arrange
      const expiresAt = Date.now() + (mockTokenData.expires_in * 1000);
      const expectedCredentials = {
        claudeAiOauth: {
          accessToken: mockTokenData.access_token,
          refreshToken: mockTokenData.refresh_token,
          expiresAt: expiresAt,
          scopes: ['user:inference', 'user:profile'],
          isMax: true,
        },
      };

      fs.mkdir.mockResolvedValue();
      fs.writeFile.mockResolvedValue();

      // Act
      await fs.mkdir(path.dirname(expectedCredentialsPath), { recursive: true });
      await fs.writeFile(
        expectedCredentialsPath,
        JSON.stringify(expectedCredentials, null, 2),
        'utf8'
      );

      // Assert
      expect(fs.mkdir).toHaveBeenCalledWith(
        path.dirname(expectedCredentialsPath),
        { recursive: true }
      );
      expect(fs.writeFile).toHaveBeenCalledWith(
        expectedCredentialsPath,
        JSON.stringify(expectedCredentials, null, 2),
        'utf8'
      );
    });

    it('should handle existing credentials file', async () => {
      // Arrange
      const existingCredentials = {
        someOtherService: {
          token: 'existing-token',
        },
      };

      const newCredentials = {
        claudeAiOauth: {
          accessToken: mockTokenData.access_token,
          refreshToken: mockTokenData.refresh_token,
          expiresAt: Date.now() + (mockTokenData.expires_in * 1000),
          scopes: ['user:inference', 'user:profile'],
          isMax: true,
        },
      };

      fs.readFile.mockResolvedValue(JSON.stringify(existingCredentials));
      fs.writeFile.mockResolvedValue();

      // Act
      const existingContent = await fs.readFile(expectedCredentialsPath, 'utf8');
      const existingData = JSON.parse(existingContent);
      const mergedCredentials = { ...existingData, ...newCredentials };

      await fs.writeFile(
        expectedCredentialsPath,
        JSON.stringify(mergedCredentials, null, 2),
        'utf8'
      );

      // Assert
      expect(mergedCredentials.someOtherService).toBeDefined();
      expect(mergedCredentials.claudeAiOauth).toBeDefined();
    });

    it('should create credentials directory if it does not exist', async () => {
      // Arrange
      const credentialsDir = path.dirname(expectedCredentialsPath);
      fs.mkdir.mockResolvedValue();
      fs.writeFile.mockResolvedValue();

      // Act
      await fs.mkdir(credentialsDir, { recursive: true });

      // Assert
      expect(fs.mkdir).toHaveBeenCalledWith(credentialsDir, { recursive: true });
    });

    it('should handle file system errors during credentials save', async () => {
      // Arrange
      const writeError = new Error('EACCES: permission denied');
      writeError.code = 'EACCES';
      fs.mkdir.mockResolvedValue();
      fs.writeFile.mockRejectedValue(writeError);

      // Act & Assert
      await expect(fs.writeFile(expectedCredentialsPath, 'test')).rejects.toThrow('EACCES: permission denied');
    });
  });

  describe('State Cleanup', () => {
    const mockStatePath = '/tmp/oauth-state.json';

    it('should delete state file after successful completion', async () => {
      // Arrange
      fs.unlink.mockResolvedValue();

      // Act
      await fs.unlink(mockStatePath);

      // Assert
      expect(fs.unlink).toHaveBeenCalledWith(mockStatePath);
    });

    it('should handle missing state file during cleanup', async () => {
      // Arrange
      const unlinkError = new Error('ENOENT: no such file or directory');
      unlinkError.code = 'ENOENT';
      fs.unlink.mockRejectedValue(unlinkError);

      // Act & Assert
      await expect(fs.unlink(mockStatePath)).rejects.toThrow('ENOENT: no such file or directory');
    });

    it('should handle permissions error during cleanup', async () => {
      // Arrange
      const unlinkError = new Error('EPERM: operation not permitted');
      unlinkError.code = 'EPERM';
      fs.unlink.mockRejectedValue(unlinkError);

      // Act & Assert
      await expect(fs.unlink(mockStatePath)).rejects.toThrow('EPERM: operation not permitted');
    });
  });

  describe('Error Handling', () => {
    it('should handle invalid authorization codes', () => {
      // Arrange
      const invalidCodes = ['', null, undefined, 'invalid-format'];

      invalidCodes.forEach(code => {
        // Act
        const isValid = code && typeof code === 'string' && code.length > 0;

        // Assert
        if (code === '' || code === null || code === undefined) {
          expect(isValid).toBe(false);
        } else {
          expect(isValid).toBe(true);
        }
      });
    });

    it('should handle OAuth error responses', () => {
      // Arrange
      const oauthErrors = [
        { error: 'invalid_request', error_description: 'Missing required parameter' },
        { error: 'invalid_client', error_description: 'Client authentication failed' },
        { error: 'invalid_grant', error_description: 'Authorization code is invalid' },
        { error: 'unauthorized_client', error_description: 'Client not authorized' },
        { error: 'unsupported_grant_type', error_description: 'Grant type not supported' },
        { error: 'invalid_scope', error_description: 'Requested scope is invalid' },
      ];

      oauthErrors.forEach(oauthError => {
        // Act & Assert
        expect(oauthError.error).toBeTruthy();
        expect(oauthError.error_description).toBeTruthy();
        expect(typeof oauthError.error).toBe('string');
        expect(typeof oauthError.error_description).toBe('string');
      });
    });

    it('should validate token response format', () => {
      // Arrange
      const validResponse = {
        access_token: 'token123',
        refresh_token: 'refresh123',
        expires_in: 3600,
        token_type: 'Bearer',
      };

      const invalidResponses = [
        {}, // Missing required fields
        { access_token: 'token123' }, // Missing other required fields
        { access_token: '', refresh_token: '', expires_in: 0 }, // Empty values
        { access_token: null, refresh_token: null }, // Null values
      ];

      // Act & Assert
      const isValidResponse = (response) => {
        return response.access_token &&
               response.refresh_token &&
               typeof response.expires_in === 'number' &&
               response.expires_in > 0;
      };

      expect(isValidResponse(validResponse)).toBe(true);

      invalidResponses.forEach(response => {
        expect(isValidResponse(response)).toBe(false);
      });
    });

    it('should handle malformed JSON responses', () => {
      // Arrange
      const malformedResponses = [
        'invalid json',
        '{"incomplete": json',
        '',
        null,
        undefined,
      ];

      malformedResponses.forEach(response => {
        if (response === null || response === undefined || response === '') {
          // Act & Assert
          expect(() => JSON.parse(response || '')).toThrow();
        } else {
          expect(() => JSON.parse(response)).toThrow();
        }
      });
    });
  });

  describe('Integration Scenarios', () => {
    it('should handle complete successful flow', async () => {
      // Arrange
      const mockState = {
        state: 'test-state-123',
        code_verifier: 'test-code-verifier-456',
        timestamp: Date.now(),
      };

      const mockTokenResponse = {
        access_token: 'access_token_12345',
        refresh_token: 'refresh_token_67890',
        expires_in: 3600,
        token_type: 'Bearer',
      };

      fs.readFile.mockResolvedValue(JSON.stringify(mockState));
      fs.mkdir.mockResolvedValue();
      fs.writeFile.mockResolvedValue();
      fs.unlink.mockResolvedValue();

      // Act - Simulate the full flow
      const stateContent = await fs.readFile('/tmp/oauth-state.json', 'utf8');
      const parsedState = JSON.parse(stateContent);

      // Token exchange would happen here
      const credentials = {
        claudeAiOauth: {
          accessToken: mockTokenResponse.access_token,
          refreshToken: mockTokenResponse.refresh_token,
          expiresAt: Date.now() + (mockTokenResponse.expires_in * 1000),
          scopes: ['user:inference', 'user:profile'],
          isMax: true,
        },
      };

      const credentialsPath = path.join(os.homedir(), '.claude', '.credentials.json');
      await fs.mkdir(path.dirname(credentialsPath), { recursive: true });
      await fs.writeFile(credentialsPath, JSON.stringify(credentials, null, 2), 'utf8');
      await fs.unlink('/tmp/oauth-state.json');

      // Assert
      expect(parsedState.state).toBe(mockState.state);
      expect(parsedState.code_verifier).toBe(mockState.code_verifier);
      expect(fs.writeFile).toHaveBeenCalledWith(
        credentialsPath,
        JSON.stringify(credentials, null, 2),
        'utf8'
      );
      expect(fs.unlink).toHaveBeenCalledWith('/tmp/oauth-state.json');
    });

    it('should not cleanup state file on failure', async () => {
      // Arrange
      const writeError = new Error('Failed to save credentials');
      fs.readFile.mockResolvedValue(JSON.stringify({ state: 'test', code_verifier: 'test' }));
      fs.writeFile.mockRejectedValue(writeError);

      // Act & Assert
      await expect(fs.writeFile('test-path', 'test-content')).rejects.toThrow('Failed to save credentials');
      // State cleanup (fs.unlink) should not be called on failure
      expect(fs.unlink).not.toHaveBeenCalled();
    });
  });
});
