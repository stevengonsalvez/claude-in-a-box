--- Dir map (depth 2) ---
.
.claude
.claude-box
.claude-box/logs
.claude/action-summaries
.claude/session
.git
.git/hooks
.git/info
.git/logs
.git/objects
.git/refs
.git/worktrees
docker
docker/claude-dev
docs
handover
logs
src
src/agent_parsers
src/app
src/claude
src/components
src/config
src/docker
src/git
src/models
target
target/debug
target/doc
target/release
tests
\n--- Cargo.toml ---
[package]
name = "claude-box"
version = "0.1.0"
edition = "2021"
authors = ["Claude-in-a-Box Team"]
description = "Terminal-based development environment manager for Claude Code containers"
license = "MIT"
repository = "https://github.com/your-org/claude-box"
keywords = ["claude", "docker", "tui", "development", "containers"]
categories = ["command-line-utilities", "development-tools"]

[dependencies]
# Core
tokio = { version = "1.36", features = ["full"] }
ratatui = "0.26"
crossterm = "0.27"

# Docker
bollard = "0.16"
futures-util = "0.3"
tar = "0.4"

# Git operations
git2 = "0.18"

# Data persistence
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
toml = "0.8"

# Claude API integration
reqwest = { version = "0.11", features = ["json", "stream"] }
async-stream = "0.3"
tokio-stream = "0.1"

# Utils
anyhow = "1.0"
thiserror = "1.0"
directories = "5.0"
dirs = "5.0"
uuid = { version = "1.5", features = ["v4", "serde"] }
chrono = { version = "0.4", features = ["serde"] }
tracing = "0.1"
tracing-subscriber = { version = "0.3", features = ["env-filter"] }
clap = { version = "4.4", features = ["derive"] }
tempfile = "3.8"
nix = { version = "0.27", features = ["user"] }
arboard = "3.3"  # Cross-platform clipboard support
regex = "1.10"
lazy_static = "1.4"

[dev-dependencies]
mockall = "0.12"
pretty_assertions = "1.4"

[profile.release]
lto = true
codegen-units = 1
strip = true
opt-level = "z"

# Linting configuration
[lints.rust]
unsafe_code = "forbid"
missing_docs = "warn"
unused_imports = "warn"
unused_variables = "warn"
dead_code = "warn"

[lints.clippy]
all = "warn"
pedantic = "warn"
nursery = "warn"
cargo = "warn"
# Allow some pedantic lints that can be overly strict
module_name_repetitions = "allow"
similar_names = "allow"
must_use_candidate = "allow"
missing_errors_doc = "allow"
missing_panics_doc = "allow"
\n--- src/docker/log_streaming.rs (head) ---
// ABOUTME: Docker log streaming manager for real-time container log collection
// Streams logs from Docker containers to the live logs UI component

use crate::agent_parsers::{AgentOutputParser, ParserFactory};
use crate::components::live_logs_stream::{LogEntry, LogEntryLevel};
use crate::components::log_parser::LogParser;
use crate::docker::ContainerManager;
use anyhow::{Result, anyhow};
use bollard::container::{LogOutput, LogsOptions};
use futures_util::StreamExt;
use std::collections::HashMap;
use tokio::sync::mpsc;
use tokio::task::JoinHandle;
use tracing::{debug, error, info, warn};
use uuid::Uuid;

#[derive(Debug)]
pub struct DockerLogStreamingManager {
    container_manager: ContainerManager,
    streaming_tasks: HashMap<Uuid, StreamingTask>,
    log_sender: mpsc::UnboundedSender<(Uuid, LogEntry)>,
    session_modes: HashMap<Uuid, crate::models::SessionMode>, // Track session modes for proper parsing
}

#[derive(Debug)]
struct StreamingTask {
    container_id: String,
    container_name: String,
    task_handle: JoinHandle<()>,
}

impl DockerLogStreamingManager {
    /// Create a new log streaming manager
    pub fn new(log_sender: mpsc::UnboundedSender<(Uuid, LogEntry)>) -> Result<Self> {
        Ok(Self {
            container_manager: ContainerManager::new_sync()?,
            streaming_tasks: HashMap::new(),
            log_sender,
            session_modes: HashMap::new(),
        })
    }

    /// Start streaming logs for a session's container
    pub async fn start_streaming(
        &mut self,
        session_id: Uuid,
        container_id: String,
        container_name: String,
        session_mode: crate::models::SessionMode,
    ) -> Result<()> {
        // Stop any existing streaming for this session
        self.stop_streaming(session_id).await?;

        info!(
            "Starting log streaming for session {} (container: {}) in {:?} mode",
            session_id, container_id, session_mode
        );

        // Store session mode for parsing
        self.session_modes.insert(session_id, session_mode.clone());

        let log_sender = self.log_sender.clone();
        let container_id_clone = container_id.clone();
        let container_name_clone = container_name.clone();
        let docker = self.container_manager.get_docker_client();

        // Spawn a task to stream logs
        let task_handle = tokio::spawn(async move {
            if let Err(e) = Self::stream_container_logs(
                docker,
                session_id,
                container_id_clone.clone(),
                container_name_clone.clone(),
                log_sender,
                session_mode,
            )
            .await
            {
                error!(
                    "Log streaming error for container {}: {}",
                    container_id_clone, e
                );
            }
        });

        self.streaming_tasks.insert(
            session_id,
            StreamingTask {
                container_id,
                container_name,
                task_handle,
            },
        );

        Ok(())
    }

    /// Stop streaming logs for a session
    pub async fn stop_streaming(&mut self, session_id: Uuid) -> Result<()> {
        if let Some(task) = self.streaming_tasks.remove(&session_id) {
            info!(
                "Stopping log streaming for session {} (container: {})",
                session_id, task.container_id
            );
            task.task_handle.abort();
        }
        // Remove session mode tracking
        self.session_modes.remove(&session_id);
        Ok(())
    }

    /// Stop all log streaming
    pub async fn stop_all_streaming(&mut self) -> Result<()> {
        info!("Stopping all log streaming tasks");
        for (_, task) in self.streaming_tasks.drain() {
            task.task_handle.abort();
        }
        // Clear all session mode tracking
        self.session_modes.clear();
        Ok(())
    }

    /// Get active streaming sessions
    pub fn active_sessions(&self) -> Vec<Uuid> {
        self.streaming_tasks.keys().cloned().collect()
    }

    /// Check if streaming is active for a session
    pub fn is_streaming(&self, session_id: Uuid) -> bool {
        self.streaming_tasks.contains_key(&session_id)
    }

    /// Stream logs from a container
    async fn stream_container_logs(
        docker: bollard::Docker,
        session_id: Uuid,
        container_id: String,
        container_name: String,
        log_sender: mpsc::UnboundedSender<(Uuid, LogEntry)>,
        session_mode: crate::models::SessionMode,
    ) -> Result<()> {
        let options = LogsOptions::<String> {
            stdout: true,
            stderr: true,
            follow: true,
            timestamps: true,
            tail: "100".to_string(), // Start with last 100 lines
            ..Default::default()
        };

        debug!(
            "Starting log stream for container {} (session {})",
            container_id, session_id
        );

        let mut log_stream = docker.logs(&container_id, Some(options));
        let mut log_parser = LogParser::new();
        
        // For boss mode, we'll also check for JSON format
        let mut agent_parser: Option<Box<dyn AgentOutputParser>> = None;
        let is_boss_mode = matches!(session_mode, crate::models::SessionMode::Boss);

        // Send initial connection message
        let _ = log_sender.send((
            session_id,
            LogEntry::new(
                LogEntryLevel::Info,
                "system".to_string(),
                format!("üì° Connected to container logs: {}", container_name),
            )
            .with_session(session_id),
        ));

        while let Some(log_result) = log_stream.next().await {
            match log_result {
                Ok(log_output) => {
                    // Extract raw message
                    let raw_message = match &log_output {
                        LogOutput::StdOut { message } | 
                        LogOutput::StdErr { message } |
                        LogOutput::Console { message } |
                        LogOutput::StdIn { message } => String::from_utf8_lossy(message).to_string(),
                    };
                    
                    // For boss mode, check each line to see if it contains Claude JSON output
                    // Docker logs format: "2025-09-08T19:20:30.123456789Z {"type":"..."}"
                    // We need to handle both JSON lines (from Claude) and regular log lines (initialization, etc.)
                    
                    let contains_claude_json = raw_message.contains(r#"{"type":"#) && 
                                              (raw_message.contains(r#""assistant""#) || 
                                               raw_message.contains(r#""user""#) || 
                                               raw_message.contains(r#""system""#));
                    
                    // Track whether we successfully parsed as JSON
                    let mut handled_as_json = false;
                    
                    // If this is boss mode and we found Claude JSON, parse it
                    if is_boss_mode && contains_claude_json {
                        // Create parser if we don't have one yet
                        if agent_parser.is_none() {
\n--- src/agent_parsers/mod.rs ---
// ABOUTME: Agent output parser module - provides modular parsing for different AI agent outputs
// Supports Claude JSON streaming, plain text, and extensible for future agents

pub mod types;
pub mod claude_json;
pub mod plain_text;

pub use types::{AgentEvent, AgentOutputParser, ParserFactory, ParserState, McpServerInfo};
pub use claude_json::ClaudeJsonParser;
pub use plain_text::PlainTextParser;\n--- src/agent_parsers/types.rs (head) ---
// ABOUTME: Common types for agent output parsing - unified representation across different AI agents
// This module defines the common event types that all agent parsers convert to

use serde::{Deserialize, Serialize};
use serde_json::Value;
use std::collections::HashMap;

/// Unified representation of events from AI agents
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum AgentEvent {
    /// Initial session information
    SessionInfo {
        model: String,
        tools: Vec<String>,
        session_id: String,
        #[serde(skip_serializing_if = "Option::is_none")]
        mcp_servers: Option<Vec<McpServerInfo>>,
    },
    
    /// Agent is thinking (for agents that expose thinking)
    Thinking {
        content: String,
    },
    
    /// Text message from agent
    Message {
        content: String,
        #[serde(skip_serializing_if = "Option::is_none")]
        id: Option<String>,
    },
    
    /// Streaming text delta (incremental updates)
    StreamingText {
        delta: String,
        #[serde(skip_serializing_if = "Option::is_none")]
        message_id: Option<String>,
    },
    
    /// Tool call initiated by agent
    ToolCall {
        id: String,
        name: String,
        input: Value,
        #[serde(skip_serializing_if = "Option::is_none")]
        description: Option<String>,
    },
    
    /// Result from a tool call
    ToolResult {
        tool_use_id: String,
        content: String,
        is_error: bool,
    },
    
    /// Error event
    Error {
        message: String,
        #[serde(skip_serializing_if = "Option::is_none")]
        code: Option<String>,
    },
    
    /// Usage statistics
    Usage {
        input_tokens: u32,
        output_tokens: u32,
        #[serde(skip_serializing_if = "Option::is_none")]
        cache_tokens: Option<u32>,
        #[serde(skip_serializing_if = "Option::is_none")]
        total_cost: Option<f64>,
    },
    
    /// Custom event for agent-specific features
    Custom {
        event_type: String,
        data: Value,
    },
}

/// MCP Server information
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct McpServerInfo {
    pub name: String,
    pub status: String,
}

/// State tracking for streaming parsers
#[derive(Debug, Clone, Default)]
pub struct ParserState {
    /// Current message being built
    pub current_message: Option<String>,
    /// Current message ID for streaming
    pub current_message_id: Option<String>,
    /// Active tool calls waiting for results
    pub active_tool_calls: HashMap<String, ToolCallInfo>,
    /// Buffer for incomplete JSON lines
    pub line_buffer: String,
    /// Whether we're in a thinking block
    pub in_thinking: bool,
}

/// Information about an active tool call
#[derive(Debug, Clone)]
pub struct ToolCallInfo {
    pub id: String,
    pub name: String,
    pub started_at: chrono::DateTime<chrono::Utc>,
}

/// Trait for parsing agent-specific output formats
pub trait AgentOutputParser: Send + Sync {
    /// Parse a line of output and return any complete events
    fn parse_line(&mut self, line: &str) -> Result<Vec<AgentEvent>, String>;
    
    /// Flush any pending events (e.g., incomplete streaming text)
    fn flush(&mut self) -> Vec<AgentEvent>;
    
    /// Get the agent type this parser handles
    fn agent_type(&self) -> &str;
    
    /// Reset parser state
    fn reset(&mut self);
}

/// Factory for creating appropriate parser based on detected format
pub struct ParserFactory;

impl ParserFactory {
    /// Create a parser based on detected output format
    pub fn create_parser(first_line: &str) -> Box<dyn AgentOutputParser> {
        // Try to detect JSON format
        if first_line.starts_with('{') && first_line.contains("\"type\"") {
            Box::new(crate::agent_parsers::claude_json::ClaudeJsonParser::new())
        } else {
            // Default to plain text parser
            Box::new(crate::agent_parsers::plain_text::PlainTextParser::new())
        }
    }
    
    /// Create a parser for a specific agent type
    pub fn create_for_agent(agent_type: &str) -> Box<dyn AgentOutputParser> {
        match agent_type.to_lowercase().as_str() {
            "claude" | "claude-json" => Box::new(crate::agent_parsers::claude_json::ClaudeJsonParser::new()),
            "plain" | "text" => Box::new(crate::agent_parsers::plain_text::PlainTextParser::new()),
            _ => Box::new(crate::agent_parsers::plain_text::PlainTextParser::new()),
        }
    }
}\n--- src/agent_parsers/claude_json.rs (head) ---
// ABOUTME: Claude JSON stream parser - parses Claude's --output-format stream-json output
// Converts Claude-specific JSON events into unified AgentEvent types for display

use super::types::{AgentEvent, AgentOutputParser, McpServerInfo, ParserState, ToolCallInfo};
use serde::{Deserialize, Serialize};
use serde_json::Value;
use std::collections::HashMap;
use tracing::{debug, warn};

/// Parser for Claude's stream-json output format
pub struct ClaudeJsonParser {
    state: ParserState,
}

impl ClaudeJsonParser {
    pub fn new() -> Self {
        Self {
            state: ParserState::default(),
        }
    }
    
    fn parse_json_event(&mut self, json_str: &str) -> Result<Vec<AgentEvent>, String> {
        let value: Value = serde_json::from_str(json_str)
            .map_err(|e| format!("Failed to parse JSON: {}", e))?;
        
        let mut events = Vec::new();
        
        // Extract type field
        let event_type = value.get("type")
            .and_then(|v| v.as_str())
            .unwrap_or("unknown");
        
        match event_type {
            "system" => {
                if let Some(subtype) = value.get("subtype").and_then(|v| v.as_str()) {
                    if subtype == "init" {
                        events.push(self.parse_system_init(&value)?);
                    }
                }
            }
            
            "assistant" => {
                events.extend(self.parse_assistant_message(&value)?);
            }
            
            "user" => {
                events.extend(self.parse_user_message(&value)?);
            }
            
            _ => {
                debug!("Unknown event type: {} - {}", event_type, json_str);
            }
        }
        
        Ok(events)
    }
    
    fn parse_system_init(&mut self, value: &Value) -> Result<AgentEvent, String> {
        let model = value.get("model")
            .and_then(|v| v.as_str())
            .unwrap_or("unknown")
            .to_string();
        
        let session_id = value.get("session_id")
            .and_then(|v| v.as_str())
            .unwrap_or("")
            .to_string();
        
        let tools = value.get("tools")
            .and_then(|v| v.as_array())
            .map(|arr| {
                arr.iter()
                    .filter_map(|v| v.as_str().map(String::from))
                    .collect()
            })
            .unwrap_or_default();
        
        let mcp_servers = value.get("mcp_servers")
            .and_then(|v| v.as_array())
            .map(|arr| {
                arr.iter()
                    .filter_map(|server| {
                        let name = server.get("name")?.as_str()?;
                        let status = server.get("status")?.as_str()?;
                        Some(McpServerInfo {
                            name: name.to_string(),
                            status: status.to_string(),
                        })
                    })
                    .collect::<Vec<_>>()
            });
        
        Ok(AgentEvent::SessionInfo {
            model,
            tools,
            session_id,
            mcp_servers,
        })
    }
    
    fn parse_assistant_message(&mut self, value: &Value) -> Result<Vec<AgentEvent>, String> {
        let mut events = Vec::new();
        
        // Get message content
        if let Some(message) = value.get("message") {
            let message_id = message.get("id")
                .and_then(|v| v.as_str())
                .map(String::from);
            
            // Store message ID for streaming
            self.state.current_message_id = message_id.clone();
            
            // Check for content array
            if let Some(content_array) = message.get("content").and_then(|v| v.as_array()) {
                for content_item in content_array {
                    let content_type = content_item.get("type")
                        .and_then(|v| v.as_str())
                        .unwrap_or("");
                    
                    match content_type {
                        "text" => {
                            if let Some(text) = content_item.get("text").and_then(|v| v.as_str()) {
                                // Check if this is a complete message or streaming delta
                                if self.state.current_message.is_some() {
                                    // Streaming delta
                                    self.state.current_message.as_mut().unwrap().push_str(text);
                                    events.push(AgentEvent::StreamingText {
                                        delta: text.to_string(),
                                        message_id: message_id.clone(),
                                    });
                                } else {
                                    // Complete message
                                    events.push(AgentEvent::Message {
                                        content: text.to_string(),
                                        id: message_id.clone(),
                                    });
                                }
                            }
                        }
                        
                        "tool_use" => {
                            let tool_id = content_item.get("id")
                                .and_then(|v| v.as_str())
                                .unwrap_or("")
                                .to_string();
                            
                            let tool_name = content_item.get("name")
                                .and_then(|v| v.as_str())
                                .unwrap_or("unknown")
                                .to_string();
                            
                            let input = content_item.get("input")
                                .cloned()
                                .unwrap_or(Value::Null);
                            
                            // Extract description from input if available
                            let description = input.get("description")
                                .and_then(|v| v.as_str())
                                .map(String::from);
                            
                            // Track active tool call
                            self.state.active_tool_calls.insert(
                                tool_id.clone(),
                                ToolCallInfo {
                                    id: tool_id.clone(),
                                    name: tool_name.clone(),
                                    started_at: chrono::Utc::now(),
                                }
                            );
                            
                            events.push(AgentEvent::ToolCall {
                                id: tool_id,
                                name: tool_name,
                                input,
                                description,
                            });
                        }
                        
                        _ => {
                            debug!("Unknown content type in assistant message: {}", content_type);
                        }
                    }
                }
            }
            
            // Check for usage information
            if let Some(usage) = message.get("usage") {
                let input_tokens = usage.get("input_tokens")
                    .and_then(|v| v.as_u64())
                    .unwrap_or(0) as u32;
                
                let output_tokens = usage.get("output_tokens")
                    .and_then(|v| v.as_u64())
                    .unwrap_or(0) as u32;
                
                let cache_tokens = usage.get("cache_read_input_tokens")
                    .and_then(|v| v.as_u64())
                    .map(|v| v as u32);
                
                events.push(AgentEvent::Usage {
\n--- src/components/live_logs_stream.rs (head) ---
// ABOUTME: Live Docker log streaming component for real-time container monitoring

use crate::app::AppState;
use super::log_formatter_simple::{SimpleLogFormatter, FormatConfig};
use ratatui::{
    prelude::*,
    style::{Color, Style},
    text::Line,
    widgets::{Block, Borders, Paragraph, Wrap},
};

pub struct LiveLogsStreamComponent {
    auto_scroll: bool,
    scroll_offset: usize,
    max_visible_lines: usize,
    show_timestamps: bool,
    filter_level: LogLevel,
    log_formatter: SimpleLogFormatter,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum LogLevel {
    All,
    Info,
    Warn,
    Error,
}

impl LogLevel {
    fn as_str(&self) -> &'static str {
        match self {
            LogLevel::All => "ALL",
            LogLevel::Info => "INFO",
            LogLevel::Warn => "WARN",
            LogLevel::Error => "ERROR",
        }
    }

    fn next(&self) -> Self {
        match self {
            LogLevel::All => LogLevel::Info,
            LogLevel::Info => LogLevel::Warn,
            LogLevel::Warn => LogLevel::Error,
            LogLevel::Error => LogLevel::All,
        }
    }
}

impl LiveLogsStreamComponent {
    pub fn new() -> Self {
        let format_config = FormatConfig {
            show_timestamps: true,
            use_relative_time: true,
            show_source_badges: true,
            compact_mode: false,
            max_message_length: None,
        };
        
        Self {
            auto_scroll: true,
            scroll_offset: 0,
            max_visible_lines: 20,
            show_timestamps: true,
            filter_level: LogLevel::All,
            log_formatter: SimpleLogFormatter::new(format_config),
        }
    }

    pub fn render(&mut self, frame: &mut Frame, area: Rect, state: &AppState) {
        // Get logs from the selected session
        let session_logs = self.get_session_logs(state);

        // Filter logs based on level
        let filtered_logs = self.filter_logs(&session_logs);

        let title = self.build_title(state, filtered_logs.len(), session_logs.len());

        // Show focus indicator
        use crate::app::state::FocusedPane;
        let (border_color, title_color) = match state.focused_pane {
            FocusedPane::LiveLogs => (Color::Cyan, Color::Yellow), // Focused
            FocusedPane::Sessions => (Color::Gray, Color::Blue),   // Not focused
        };

        let block = Block::default()
            .borders(Borders::ALL)
            .title(title)
            .title_style(Style::default().fg(title_color))
            .border_style(Style::default().fg(border_color));

        if filtered_logs.is_empty() {
            let empty_message = match self.filter_level {
                LogLevel::All => {
                    "No logs available\n\nLogs will appear here when containers are active."
                }
                _ => &format!(
                    "No {} level logs\n\nAdjust filter level with 'f' key.",
                    self.filter_level.as_str().to_lowercase()
                ),
            };

            frame.render_widget(
                Paragraph::new(empty_message)
                    .block(block)
                    .style(Style::default().fg(Color::Gray))
                    .alignment(Alignment::Center),
                area,
            );
            return;
        }

        // Get scroll position before borrowing self mutably
        let scroll_pos = self.get_scroll_position(&filtered_logs);
        
        // Create formatted log lines using the beautiful formatter
        let log_lines = self.create_formatted_log_lines(&filtered_logs);

        let paragraph = Paragraph::new(log_lines)
            .block(block)
            .wrap(Wrap { trim: false })
            .scroll((scroll_pos as u16, 0));

        frame.render_widget(paragraph, area);

        // Render controls hint
        self.render_controls_hint(frame, area);

        // Update max visible lines based on actual area
        self.max_visible_lines = (area.height.saturating_sub(4)) as usize;
    }

    fn get_session_logs(&self, state: &AppState) -> Vec<LogEntry> {
        // Get logs from currently selected session or all active sessions
        if let Some(session) = state.selected_session() {
            // Get logs for specific session
            state.live_logs.get(&session.id).cloned().unwrap_or_default()
        } else {
            // Aggregate logs from all active sessions
            let mut all_logs = Vec::new();
            for workspace in &state.workspaces {
                for session in &workspace.sessions {
                    if let Some(logs) = state.live_logs.get(&session.id) {
                        all_logs.extend(logs.iter().cloned());
                    }
                }
            }

            // Sort by timestamp
            all_logs.sort_by_key(|log| log.timestamp);
            all_logs
        }
    }

    fn filter_logs<'a>(&self, logs: &'a [LogEntry]) -> Vec<&'a LogEntry> {
        logs.iter().filter(|log| self.should_include_log(log)).collect()
    }

    fn should_include_log(&self, log: &LogEntry) -> bool {
        match self.filter_level {
            LogLevel::All => true,
\n--- docker/claude-dev/scripts/startup.sh ---
#!/bin/bash
# ABOUTME: Startup script for claude-dev container
# Handles environment setup, authentication, and CLI initialization

set -e

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

log() {
    echo -e "${BLUE}[claude-box]${NC} $1"
}

warn() {
    echo -e "${YELLOW}[claude-box]${NC} $1"
}

error() {
    echo -e "${RED}[claude-box]${NC} $1"
}

success() {
    echo -e "${GREEN}[claude-box]${NC} $1"
}

# Load environment variables from .env if it exists
if [ -f /app/.env ]; then
    log "Loading environment variables from .env"
    set -a
    source /app/.env
    set +a
fi

# Check claude-box session mode
if [ "${CLAUDE_BOX_MODE}" = "boss" ]; then
    log "Running in claude-box boss mode"
elif [ "${CLAUDE_BOX_MODE}" = "interactive" ]; then
    log "Running in claude-box interactive mode"
elif [ "${CLAUDE_BOX_MODE}" = "true" ]; then
    # Legacy support
    log "Running in claude-box mode (legacy)"
fi

# Check for existing authentication (multiple sources)
AUTH_OK=false
AUTH_SOURCES=()

# Handle authentication for parallel sessions
# Priority: 1. Mounted .claude.json (OAuth tokens), 2. Environment variable, 3. Credentials file

# Check for mounted .claude.json first (OAuth tokens from Claude Max)
if [ -f /home/claude-user/.claude.json ] && [ -s /home/claude-user/.claude.json ]; then
    AUTH_SOURCES+=(".claude.json (OAuth tokens)")
    AUTH_OK=true
    log "Using mounted .claude.json with OAuth authentication"
elif [ -n "${ANTHROPIC_API_KEY}" ]; then
    AUTH_SOURCES+=("ANTHROPIC_API_KEY environment variable")
    AUTH_OK=true
    log "Using ANTHROPIC_API_KEY environment variable for authentication"
fi

# Check for .claude directory with credentials (if no auth found yet)
if [ "${AUTH_OK}" = "false" ] && [ -f /home/claude-user/.claude/.credentials.json ] && [ -s /home/claude-user/.claude/.credentials.json ]; then
    AUTH_SOURCES+=(".claude/.credentials.json (claude-in-a-box)")
    AUTH_OK=true
fi

if [ "${AUTH_OK}" = "true" ]; then
    log "Found Claude authentication via: ${AUTH_SOURCES[*]}"
else
    warn "No Claude authentication found!"
    warn "Please ensure one of:"
    warn "  1. Run 'claude-box auth' to set up authentication"
    warn "  2. Have ~/.claude-in-a-box/auth/.credentials.json (mounted to /home/claude-user/.claude/.credentials.json)"
    warn "  3. Set ANTHROPIC_API_KEY in environment"
fi

# Create .claude directory if it doesn't exist (unless it's already mounted)
if [ ! -d /home/claude-user/.claude ]; then
    mkdir -p /home/claude-user/.claude
fi

# Configure GitHub CLI if GITHUB_TOKEN is provided
if [ -n "${GITHUB_TOKEN}" ]; then
    log "Configuring GitHub CLI with token authentication"
    echo "${GITHUB_TOKEN}" | gh auth login --with-token

    # Configure git to use the token for authentication
    git config --global credential.helper store
    echo "https://oauth:${GITHUB_TOKEN}@github.com" > /home/claude-user/.git-credentials

    # Test gh CLI connection
    if gh auth status > /dev/null 2>&1; then
        success "GitHub CLI authenticated successfully"
        log "Available commands: gh issue list, gh pr list, gh repo view, etc."
    else
        warn "GitHub CLI authentication failed"
    fi
else
    warn "GITHUB_TOKEN not found - GitHub CLI and token-based git auth unavailable"
    log "SSH keys will be used for git operations if available"
fi

# Copy CLAUDE.md template if it doesn't exist in workspace
if [ ! -f /workspace/CLAUDE.md ] && [ -f /app/config/CLAUDE.md.template ]; then
    log "Creating CLAUDE.md from template"
    cp /app/config/CLAUDE.md.template /workspace/CLAUDE.md
fi

# Set up Claude CLI logging commands
log "Setting up Claude CLI logging commands"
if [ -f /app/scripts/claude-commands.sh ]; then
    source /app/scripts/claude-commands.sh
    log "‚úÖ Claude logging commands available: claude-ask, claude-print, claude-script"
else
    warn "Claude logging commands not found"
fi

# Ensure theme preferences are set to avoid Claude CLI theme prompt
# Check if theme is already configured
if ! claude config get -g theme >/dev/null 2>&1; then
    log "Setting default theme to avoid theme selection prompt"
    claude config set -g theme dark
else
    log "Theme already configured: $(claude config get -g theme 2>/dev/null || echo 'unknown')"
fi

# Set trust dialog to accepted to avoid prompts when using --dangerously-skip-permissions
if [[ "$CLAUDE_CONTINUE_FLAG" == *"--dangerously-skip-permissions"* ]]; then
    log "Setting trust dialog acceptance to avoid permission prompts (skip permissions enabled)"
    # Use direct binary to avoid triggering our wrapper's --dangerously-skip-permissions flag
    /home/claude-user/.npm-global/bin/claude config set hasTrustDialogAccepted true >/dev/null 2>&1 || warn "Failed to set trust dialog config"
else
    log "Trust dialog will be shown as needed (permissions enabled)"
fi

# Determine which CLI to use (adapted from claude-docker startup.sh)
CLI_CMD="claude"
CLI_ARGS="$CLAUDE_CONTINUE_FLAG"

log "Using Claude CLI with args: $CLI_ARGS"

# Handle boss mode execution
if [ "${CLAUDE_BOX_MODE}" = "boss" ] && [ -n "${CLAUDE_BOX_PROMPT}" ]; then
    # Create log directory
    mkdir -p /workspace/.claude-box/logs

    success "Container environment ready!"
    if [ "${AUTH_OK}" = "true" ]; then
        success "‚úÖ Authentication detected - Claude will work immediately"
        log "ü§ñ Executing boss mode prompt..."
        log "Prompt: ${CLAUDE_BOX_PROMPT}"

        # Boss mode prompt text to append
        BOSS_MODE_PROMPT="Ultrathink and understand our project rules, particularly around testing. You must go test first, and you must work in a way that allows for small known-good increments. You must commit when the code is in a working state, and commit early and often. When committing: - Use conventional commit format (feat:, fix:, refactor:, test:, docs:) - Commit after each logical increment (test passes, feature complete, refactor done) - Generate descriptive commit messages that explain the 'what' and 'why' - Never leave code in a broken state between commits"

        # Append boss mode prompt to user prompt
        ENHANCED_PROMPT="${CLAUDE_BOX_PROMPT} ${BOSS_MODE_PROMPT}"

        # Execute Claude with the enhanced prompt and stream-json output
        log "Running: claude --print --output-format stream-json --verbose \"${ENHANCED_PROMPT}\""
        exec claude --print --output-format stream-json --verbose "${ENHANCED_PROMPT}" $CLI_ARGS
    else
        error "‚ùå Boss mode requires authentication!"
        error "Please ensure one of:"
        error "  1. Run 'claude-box auth' to set up authentication"
        error "  2. Have ~/.claude-in-a-box/auth/.credentials.json mounted"
        error "  3. Set ANTHROPIC_API_KEY in environment"
        exit 1
    fi
elif [ "${CLAUDE_BOX_MODE}" = "boss" ]; then
    error "‚ùå Boss mode requires a prompt!"
    error "CLAUDE_BOX_PROMPT environment variable is missing or empty"
    exit 1
fi

# If no command specified, run interactive shell
if [ $# -eq 0 ]; then
    # Create log directory
    mkdir -p /workspace/.claude-box/logs

    success "Container environment ready!"
    if [ "${AUTH_OK}" = "true" ]; then
        success "‚úÖ Authentication detected - Claude will work immediately"
        success "üìù Available Claude commands:"
        success "   ‚Ä¢ claude-ask \"question\" - Ask Claude with logged response"
        success "   ‚Ä¢ claude-start - Interactive Claude CLI"
        success "   ‚Ä¢ claude-help - Show all available commands"
        success "   üí° Use claude-ask to see responses in TUI logs!"
    else
        warn "‚ö†Ô∏è  No authentication detected"
        warn "üìù Set ANTHROPIC_API_KEY or mount authentication files"
    fi

    log "Starting interactive shell..."
    # Use sleep infinity to keep container running when not attached to TTY
